# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    info.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jomunoz <jomunoz@student.42lisboa.com>     +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/08/08 22:07:20 by jomunoz           #+#    #+#              #
#    Updated: 2025/08/08 22:07:22 by jomunoz          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

    
    int access(const char *pathname, int mode);
    access checks whether the program can access the file pathname.
    if (access("rwfile", R_OK|W_OK) == 0)
        printf("rwfile is accessible in writing and reading mode\n");
    
    int dup2(int oldfd, int newfd);
    makes a copy fd
    If oldfd is not a valid file descriptor, then the call fails, 
and newfd is not closed.
    If oldfd is a valid file descriptor, and newfd has the same value as oldfd, 
then dup2() does nothing, and returns newfd.

    int pipe(int pipefd[2]);
    The array pipefd is used to return two file descriptors referring to the 
ends of the pipe. pipefd[0] refers to the read end of the pipe. pipefd[1] 
refers to the write end of the pipe. 

    pid_t fork(void);
    creates a new process by duplicating the calling process. The new process, 
referred to as the child, is an exact duplicate of the calling process, referred
to as the parent

    pid_t waitpid(pid_t pid, int *status, int options);
    The waitpid() system call suspends execution of the calling process until a 
child specified by pid argument has changed state. By default, waitpid() waits only 
for terminated children

    pid_t wait(int *status);
    The wait() system call suspends execution of the calling process until one of 
its children terminates.

    int execve(const char *filename, char *const argv[], char *const envp[]);
    execve() executes the program pointed to by filename.
    execve() does not return on succes, the calling process is replaced by the 
executed filename.

    int unlink(const char *pathname);
    unlink() deletes a name from the file system. If that name was the last link 
to a file and no processes have the file open the file is deleted and the space 
it was using is made available for reuse.


    Main checklist

    Check the existence of infile and outfile

    be sure to understand what > does when the file does not exist

    Create the necessary pipe (or pipes)

    Create a child process for each command

    Wait for all the processes to end before writing to the outfile

    
    Execute checklist

    Remember that the execve() function needs the path to a binary file 
as parameter, so you'll have to find where the commands binaries are stored 
on your computer. Before going further, you have to know how to find any command binary.

    Check in all possible locations if the binary (command) requested by the user exists.

    "Build" the arguments array for the command.

    Execute the command using execve()